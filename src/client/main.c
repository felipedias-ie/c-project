// All doxygen comments were generated by AI, model: gpt-5.

/**
 * @file main.c
 * @brief Game client - handles rendering, input, and network communication.
 */
#include <stdio.h>
#include <string.h>
#include <math.h>
#include <raylib.h>
#include <raymath.h>
#include <rlgl.h>
#include <enet.h>
#include "../common/shared.h"
// #include <stdlib.h>
// #include <time.h>

#define SCREEN_W 1600
#define SCREEN_H 900
// #define SCREEN_W 1920
// #define SCREEN_H 1080

typedef enum
{
    STATE_MENU,
    STATE_CONNECTING,
    STATE_GAME,
    STATE_DEAD
} GameState;

GameState state = STATE_MENU;
char name_buffer[16] = "Player";
int name_index = 6;
int my_id = -1;
int player_score = 0;
uint32_t last_seq = 0;

char server_ip[64] = "127.0.0.1";
int server_port = PORT;

typedef struct
{
    bool active;
    int id;
    Vector2 pos;
    Vector2 target_pos;
    float angle;
    Color color;
    char name[16];
    int score;
    int immunity;
    int trail_len;
    Vector2 trail[MAX_TRAIL];
    // float speed;
} RenderSnake;

RenderSnake snake_data[MAX_CLIENTS];
NetFood food_data[MAX_FOOD];
int food_count = 0;

ENetHost *client;
ENetPeer *peer;
Texture2D glow_texture;


/**
 * @brief To show the leaderboard entries in order.
 *
 * @param a Pointer to first RenderSnake pointer
 * @param b Pointer to second RenderSnake pointer
 * @return Negative if a > b, positive if a < b, zero if equal
 */
int compare_snakes(const void *a, const void *b)
{
    RenderSnake *s1 = *(RenderSnake **)a;
    RenderSnake *s2 = *(RenderSnake **)b;
    if (!s1->active)
        return 1;
    if (!s2->active)
        return -1;
    return s2->score - s1->score;
}

// [AI, model: gpt-5] was used to design this function.
/**
 * @brief Glow effect - try to replicate the .js version of the glow.
 *
 * Prodcedural texture generation.
 * We get the center and then use pythagoras to create a circle.
 * The soft glow is created by opacity fall off using "powf".
 * Basically replicating a shader using pure math.
 *
 * @param size Texture size (size x size pixels)
 * @param c Base color for the glow
 * @return Generated glow texture
 */
Texture2D generate_glow(int size, Color c)
{
    Image img = GenImageColor(size, size, BLANK);

    // Soft radial gradient for under-glow
    for (int y = 0; y < size; y++)
    {
        for (int x = 0; x < size; x++)
        {
            float dx = x - size / 2.0f;
            // float dy = y + size / 1.0f;
            float dy = y - size / 2.0f;

            float d = sqrtf(dx * dx + dy * dy);

            if (d < size / 2.0f)
            {
                float a = 1.0f - (d / (size / 2.0f));
                a = powf(a, 2.0f);  // makes it softer
                // a = powf(a, 1.5f);
                // a = powf(a, 3.0f);
                ImageDrawPixel(&img, x, y, ColorAlpha(c, a * 0.5f));
            }
        }
    }

    Texture2D t = LoadTextureFromImage(img);
    UnloadImage(img);
    SetTextureFilter(t, TEXTURE_FILTER_BILINEAR);
    // SetTextureFilter(t, TEXTURE_FILTER_TRILINEAR);

    return t;
}

// [AI, model: gpt-5] was used to design this function.
/**
 * @brief To draw the snake body.
 *
 * Dynamic mesh generation.
 * We draw a 1d line and expand it sideways to create a 2d mesh.
 * Efficient way to draw a snake body because it's a shape changing every single frame.
 *
 * @param trail Array of trail positions
 * @param len Number of trail segments
 * @param head Current head position
 * @param radius Snake body radius
 * @param color Fill color
 */
void draw_snake_mesh(Vector2 *trail, int len, Vector2 head, float radius, Color color)
{
    // @ least one trail point to form a body between head and tail
    if (len < 1)
        return;

    rlBegin(RL_TRIANGLES);
    rlColor4ub(color.r, color.g, color.b, color.a);

    Vector2 prev = head;
    Vector2 p2 = trail[0];

    // calculate direction vector for every two points
    Vector2 dir = Vector2Subtract(p2, prev);
    if (Vector2LengthSqr(dir) < 0.1f)
        dir = (Vector2){1, 0};
    else
        dir = Vector2Normalize(dir);

    Vector2 n  = (Vector2){-dir.y, dir.x};  // perpendicular
    Vector2 l1 = Vector2Add(prev, Vector2Scale(n, radius));
    Vector2 r1 = Vector2Subtract(prev, Vector2Scale(n, radius));

    for (int i = 0; i < len; i++)
    {
        Vector2 curr = trail[i];
        Vector2 next = (i < len - 1) ? trail[i + 1] : curr;

        Vector2 segment_dir = Vector2Subtract(curr, prev);
        
        if (Vector2LengthSqr(segment_dir) < 0.1f)
            segment_dir = (Vector2){1, 0};
        else
            segment_dir = Vector2Normalize(segment_dir);

        Vector2 segment_normal = (Vector2){-segment_dir.y, segment_dir.x};

        Vector2 l2 = Vector2Add(curr, Vector2Scale(segment_normal, radius));
        Vector2 r2 = Vector2Subtract(curr, Vector2Scale(segment_normal, radius));

        // first triangle
        rlVertex2f(l1.x, l1.y);
        rlVertex2f(r1.x, r1.y);
        rlVertex2f(l2.x, l2.y);

        // second triangle
        rlVertex2f(r1.x, r1.y);
        rlVertex2f(r2.x, r2.y);
        rlVertex2f(l2.x, l2.y);

        // step forward
        prev = curr;
        l1 = l2;
        r1 = r2;

        // update direction for the next segment if there is one
        if (i < len - 1)
        {
            Vector2 ndir = Vector2Subtract(next, curr);
            if (Vector2LengthSqr(ndir) >= 0.1f)
                dir = Vector2Normalize(ndir);
        }
    }
    rlEnd();

    DrawCircleV(head, radius, color);
    DrawCircleV(trail[len - 1], radius, color);
}

/**
 * @brief Connect to the game server.
 *
 * If we are already connected, meaning we died and are trying to respawn,
 * we just send a join packet again (JOIN_PACKET) w/ username.
 */
void connect_to_server()
{

    // printf("trying to connect...\n");
    
    if (peer && peer->state == ENET_PEER_STATE_CONNECTED)
    {
        JoinPacket p = {JOIN_PACKET};
        strcpy(p.name, name_buffer);
        
        ENetPacket *pkt = enet_packet_create(
            &p, 
            sizeof(p), 
            ENET_PACKET_FLAG_RELIABLE
        );

        enet_peer_send(peer, 0, pkt);
        
        return;
    }

    if (peer)
        enet_peer_disconnect(peer, 0);

    ENetAddress addr;
    enet_address_set_host(&addr, server_ip);
    addr.port = server_port;
    peer = enet_host_connect(client, &addr, 2, 0);

    last_seq = 0;
}

/**
 * @brief Mainloop - the heartbeat and main client logic that takes decisions and talks to the server.
 *
 * We have several packet types:
 * - INIT_PACKET
 * - DIE_PACKET: server says that we had a collision with another player and died.
 *   In this case client shows the death message.
 * - WORLD_PACKET: this is the main most complex and important packet. It contains
 *   the entire worlds state, meaning all the snakes and food positions.
 *   We use that data to display everything on screen.
 *
 * The UDP packets can arrive out of order due to lag and we cant wait for all
 * clients to respond as it is a multyplaier game and different clients can have
 * different latencies. So we use this approach: we use a sequence number and if
 * we receive packet 2 before 1, we simply discard packet 1 to stop game from
 * jittering backward and create a smooth experience.
 *
 * We also use "deserialization" - loops trough raw buf, extracts the NetSnake
 * and NetFood structs and updates the local r_snakes r_foods arrays.
 *
 * @param argc Argument count
 * @param argv Arguments: [1] = server IP, [2] = server port
 * @return 0 on success, 1 on failure
 */
int main(int argc, char **argv)
{
    if (argc > 1)
        strncpy(server_ip, argv[1], 63);
    if (argc > 2)
        server_port = atoi(argv[2]);

    // printf("Starting client...\n");
    
    SetConfigFlags(FLAG_MSAA_4X_HINT | FLAG_WINDOW_HIGHDPI);
    InitWindow(SCREEN_W, SCREEN_H, "slither.c");
    SetTargetFPS(144);

    glow_texture = generate_glow(128, WHITE); // higres texture
    // glow_texture = generate_glow(64, WHITE);
    // glow_texture = generate_glow(256, WHITE);

    // Font game_font = LoadFont("assets/font.ttf");

    if (enet_initialize() != 0)
        return 1;

    client = enet_host_create(NULL, 1, 2, 0, 0);

    Camera2D cam = {0};
    cam.zoom = 1.0f;
    cam.offset = (Vector2){SCREEN_W / 2.0f, SCREEN_H / 2.0f};

    // initialize snakes to prevent garbage data
    for (int i = 0; i < MAX_CLIENTS; i++)
        snake_data[i].active = false;

    // MAIN GAME LOOP
    while (!WindowShouldClose())
    {
        float dt = GetFrameTime();
        // printf("dt: %f\n", dt);

        // network loop
        ENetEvent event;
        while (enet_host_service(client, &event, 0) > 0)
        {
            if (event.type == ENET_EVENT_TYPE_CONNECT)
            {
                printf("Connected to server.\n");
                if (state == STATE_CONNECTING)
                {
                    JoinPacket p = {JOIN_PACKET};
                    strcpy(p.name, name_buffer);
                    ENetPacket *pkt = enet_packet_create(&p, sizeof(p), ENET_PACKET_FLAG_RELIABLE);
                    enet_peer_send(peer, 0, pkt);
                }
            }


            else if (event.type == ENET_EVENT_TYPE_RECEIVE)
            {
                uint8_t type = event.packet->data[0];

                if (type == INIT_PACKET)
                {
                    InitPacket *p = (InitPacket *)event.packet->data;
                    my_id      = p -> player_id;
                    printf("joined as ID: %d\n", my_id);

                    // we reset local camera tracking pos to 0,0 for ex if we die at 1337,7331, the camera will jump across the map when we respawn.
                    snake_data[my_id].pos        = (Vector2){0, 0};
                    snake_data[my_id].target_pos = (Vector2){0, 0};
                    snake_data[my_id].active     = true;

                    state = STATE_GAME;
                }
                
                // if we die, we set state to STATE_DEAD and reset our id so we don't track a ghost.
                // also extract final_score to show it.
                else if (type == DIE_PACKET)
                {
                    DiePacket *p = (DiePacket *)event.packet->data;
                    player_score = p->final_score;
                    // if (player_score > highscore) highscore = player_score;
                    state        = STATE_DEAD;
                    my_id        = -1;
                }

                // complex world packet.
                else if (type == WORLD_PACKET)
                {
                    WorldPacket *h = (WorldPacket *)event.packet->data;

                    // discard old packets
                    // we check if current packer is older than the last one we processed and if it is we ignore it.
                    // logic to prevent laggin backward.
                    if (h->sequence < last_seq)
                    {
                        enet_packet_destroy(event.packet);
                        continue;
                    }
                    last_seq = h->sequence;

                    // pointer to read after the pkt world header. hence why adding sizeof(WorldPacket)
                    uint8_t *ptr = event.packet->data + sizeof(WorldPacket);

                    // mark all as inactive first to handle other player's disconnects
                    // if the server doesnt send data for a certain player in this packet, we will not show them on screen.
                    bool was_active[MAX_CLIENTS];
                    for (int i = 0; i < MAX_CLIENTS; i++)
                    {
                        was_active[i] = snake_data[i].active;
                        snake_data[i].active = false;
                    }

                    // loop trough all the snakes in the world packet.
                    for (int i = 0; i < h->snake_count; i++)
                    {
                        NetSnake *ns = (NetSnake *)ptr;
                        int id = ns->id;

                        // load snake into local array with position
                        snake_data[id].active     = true;
                        snake_data[id].id         = id;
                        snake_data[id].target_pos = (Vector2){(float)ns->x, (float)ns->y};

                        // snap if the snake just spawned or is far away (teleport)
                        if (!was_active[id] || Vector2Distance(snake_data[id].pos, snake_data[id].target_pos) > 300)
                        {
                            snake_data[id].pos = snake_data[id].target_pos;
                        }

                        // copy snake properties
                        snake_data[id].angle    = ns->angle * DEG2RAD;
                        snake_data[id].score    = ns->score;
                        snake_data[id].immunity = ns->immunity;
                        snake_data[id].color    = (Color){ns->r, ns->g, ns->b, 255};
                        
                        strncpy(snake_data[id].name, ns->name, 15);

                        // copy over the snake's trail to then draw the mesh.
                        snake_data[id].trail_len = ns->trail_len;
                        for (int k = 0; k < ns->trail_len; k++)
                        {
                            snake_data[id].trail[k] = (Vector2){(float)ns->trail_x[k], (float)ns->trail_y[k]};
                        }

                        // then move our reading pointer forward by the size of snake struct to read the next snake in the loop
                        ptr += sizeof(NetSnake);
                    }

                    // loop to load all the food on the map
                    food_count = h->food_count;
                    for (int i = 0; i < h->food_count; i++)
                    {
                        food_data[i] = *(NetFood *)ptr;
                        ptr += sizeof(NetFood);
                    }

                }

                // destroy packet to free memory and stay efficient.
                enet_packet_destroy(event.packet);
            }
        }

        // player camera logic
        if (state == STATE_GAME && my_id != -1 && snake_data[my_id].active)
        {
            // camera follow
            Vector2 target = snake_data[my_id].pos;

            // to make a smooth effect and not make the camera lock onto the snake we move cam 5 * dt (dt = frame time)
            cam.target.x = Lerp(cam.target.x, target.x, 5.0f * dt);
            cam.target.y = Lerp(cam.target.y, target.y, 5.0f * dt);
            // cam.target.x = Lerp(cam.target.x, target.x, 10.0f * dt);
            // cam.target.y = Lerp(cam.target.y, target.y, 10.0f * dt);
            // cam.target = target;

            // when the snake eats food it becomes fatter so we have to zoom out if not it would fill the whole screen.
            // values are arbitrary and finetuned after some gameplay for the best experience.
            float target_zoom = 0.9f / (1.0f + snake_data[my_id].score * 0.0004f);
            if (target_zoom < 0.5f)
                target_zoom = 0.5f;
            cam.zoom = Lerp(cam.zoom, target_zoom, 2.0f * dt);

            // follow mouse input (snake goes towards mouse position)
            // atan returns angle in radians between snake and mouse.
            Vector2 mouse = GetScreenToWorld2D(GetMousePosition(), cam);
            float angle   = atan2f(mouse.y - snake_data[my_id].pos.y, mouse.x - snake_data[my_id].pos.x);

            // boost when holding left mouse button (consumes score)
            uint8_t boost = IsMouseButtonDown(MOUSE_BUTTON_LEFT) ? 1 : 0;

            InputPacket in = {INPUT_PACKET, angle, boost};
            ENetPacket *p = enet_packet_create(&in, sizeof(in), ENET_PACKET_FLAG_UNSEQUENCED);
            enet_peer_send(peer, 1, p);
        }

        // network updates arrive around 20-60 frames per second. but the monitor on mac is 120hz meanin it refreshes 120 times per second. if we only
        // update positions when packets arrive, the game would look very choppy.

        // that's why we use "linear interpolation".
        // we take the current position and the target position and interpolate between them based on the frame time.
        // this way we can smooth out the movement and make it look more fluid.

        // the formula is:
        // new_pos = current_pos + (target_pos - current_pos) * t
        // t is the frame time.
        // we use 15.0f as a tuning factor. higher = snappier, lower = smoother/laggier.

        for (int i = 0; i < MAX_CLIENTS; i++)
        {
            if (snake_data[i].active)
            {
                float t = 15.0f * dt;
                // float t = 10.0f * dt;
                if (t > 1.0f) t = 1.0f;

                snake_data[i].pos = Vector2Lerp(snake_data[i].pos, snake_data[i].target_pos, t);
            }
        }

        // render loop
        BeginDrawing();
        ClearBackground((Color){10, 12, 16, 255});
        // ClearBackground((Color){5, 5, 10, 255});
        // ClearBackground((Color){20, 22, 30, 255});
        // ClearBackground(BLACK);

        if (state == STATE_GAME)
        {
            BeginMode2D(cam);

            // grid drawing
            float grid_size = 100.0f;

            Vector2 top_left     = GetScreenToWorld2D((Vector2){0, 0}, cam);
            Vector2 bottom_right = GetScreenToWorld2D((Vector2){(float)GetScreenWidth(), (float)GetScreenHeight()}, cam);

            int start_x = (int)(top_left.x / grid_size) - 1;
            int start_y = (int)(top_left.y / grid_size) - 1;
            int end_x   = (int)(bottom_right.x / grid_size) + 1;
            int end_y   = (int)(bottom_right.y / grid_size) + 1;

            for (int x = start_x; x < end_x; x++)
                DrawLine(x * grid_size, start_y * grid_size, x * grid_size, end_y * grid_size, (Color){30, 30, 40, 255});
                // DrawLine(x * grid_size, start_y * grid_size, x * grid_size, end_y * grid_size, (Color){40, 40, 50, 255});
                // DrawLine(x * grid_size, start_y * grid_size, x * grid_size, end_y * grid_size, DARKGRAY);

            for (int y = start_y; y < end_y; y++)
                DrawLine(start_x * grid_size, y * grid_size, end_x * grid_size, y * grid_size, (Color){30, 30, 40, 255});

            // world border
            DrawCircleLines(0, 0, WORLD_SIZE / 2, (Color){100, 0, 0, 255});
            // DrawCircleLines(0, 0, WORLD_SIZE / 2, RED);

            // food
            BeginBlendMode(BLEND_ADDITIVE);
            for (int i = 0; i < food_count; i++)
            {
                // food size: rand(3,7). val is 1-3. same as .js
                float sz = 3.0f + food_data[i].val * 1.5f;
                // float sz = 5.0f + food_data[i].val * 2.0f;
                // float sz = 2.0f + food_data[i].val;
                Color c = {food_data[i].r, food_data[i].g, food_data[i].b, 200};
                // Color c = {food_data[i].r, food_data[i].g, food_data[i].b, 255};

                // draw glow (larger)
                DrawTexturePro(glow_texture, (Rectangle){0, 0, 128, 128},
                               (Rectangle){food_data[i].x - sz * 3, food_data[i].y - sz * 3, sz * 6, sz * 6}, (Vector2){0, 0}, 0, c);
                // DrawTexturePro(glow_texture, (Rectangle){0, 0, 128, 128},
                //                (Rectangle){food_data[i].x - sz * 4, food_data[i].y - sz * 4, sz * 8, sz * 8}, (Vector2){0, 0}, 0, c);

                // draw core (sharp)
                DrawCircle(food_data[i].x, food_data[i].y, sz, c);
            }
            EndBlendMode();

            // draw snakes
            for (int i = 0; i < MAX_CLIENTS; i++)
            {
                if (!snake_data[i].active)
                    continue;

                // radius: Min(80, 10 + score * 0.008) - matches server config
                float radius = 10.0f + snake_data[i].score * 0.015f;
                if (radius > 80)
                    radius = 80;

                Color c = snake_data[i].color;
                
                // flashing effect when immune
                if (snake_data[i].immunity > 0)
                {
                    c.a = 100 + (int)(sinf(GetTime() * 10) * 50);
                    // c.a = 150;
                }

                // trail (underglow first)
                BeginBlendMode(BLEND_ADDITIVE);
                for (int k = 0; k < snake_data[i].trail_len - 1; k++)
                {
                    Vector2 start = snake_data[i].trail[k];
                    Vector2 end = snake_data[i].trail[k + 1];
                    DrawLineEx(start, end, radius * 2.0f, ColorAlpha(c, 0.3f));
                    // DrawLineEx(start, end, radius * 2.5f, ColorAlpha(c, 0.2f));
                    // DrawLineEx(start, end, radius * 1.5f, ColorAlpha(c, 0.4f));
                    DrawCircleV(start, radius, ColorAlpha(c, 0.3f));
                    // DrawCircleV(start, radius * 1.2f, ColorAlpha(c, 0.2f));
                }
                EndBlendMode();

                // mesh rendering for body
                draw_snake_mesh(snake_data[i].trail, snake_data[i].trail_len, snake_data[i].pos, radius, c);

                // eyes
                float eye_offset = radius * 0.5f;
                float eye_size   = radius * 0.3f;
                float ang        = snake_data[i].angle;

                Vector2 eye_left  = {snake_data[i].pos.x + cosf(ang - 0.6f) * eye_offset, snake_data[i].pos.y + sinf(ang - 0.6f) * eye_offset};
                Vector2 eye_right = {snake_data[i].pos.x + cosf(ang + 0.6f) * eye_offset, snake_data[i].pos.y + sinf(ang + 0.6f) * eye_offset};

                DrawCircleV(eye_left, eye_size, WHITE);
                DrawCircleV(eye_right, eye_size, WHITE);

                // draw pupils
                Vector2 pupil_left  = {eye_left.x + cosf(ang) * eye_size * 0.5f, eye_left.y + sinf(ang) * eye_size * 0.5f};
                Vector2 pupil_right = {eye_right.x + cosf(ang) * eye_size * 0.5f, eye_right.y + sinf(ang) * eye_size * 0.5f};
                DrawCircleV(pupil_left, eye_size * 0.5f, BLACK);
                DrawCircleV(pupil_right, eye_size * 0.5f, BLACK);

                // player name above head
                DrawText(snake_data[i].name, snake_data[i].pos.x - MeasureText(snake_data[i].name, 20) / 2, snake_data[i].pos.y - radius - 25, 20, WHITE);
            }
            EndMode2D();

            DrawText(TextFormat("Score: %d", my_id != -1 ? snake_data[my_id].score : 0), 20, GetScreenHeight() - 50, 30, WHITE);

            // DrawFPS(10, 10);

            // leaderboard
            RenderSnake *sorted[MAX_CLIENTS];
            int count = 0;
            for (int i = 0; i < MAX_CLIENTS; i++)
                if (snake_data[i].active)
                    sorted[count++] = &snake_data[i];
            qsort(sorted, count, sizeof(RenderSnake *), compare_snakes);

            int leaderboard_x = GetScreenWidth() - 220;
            // int leaderboard_x = GetScreenWidth() - 250;
            // int leaderboard_x = 20;
            DrawRectangle(leaderboard_x, 10, 210, 25 + count * 20, (Color){0, 0, 0, 150});
            // DrawRectangle(leaderboard_x, 10, 210, 25 + count * 20, (Color){0, 0, 0, 200});
            // DrawRectangle(leaderboard_x, 10, 230, 30 + count * 22, (Color){20, 20, 30, 180});
            DrawText("Leaderboard", leaderboard_x + 20, 15, 20, GOLD);
            for (int i = 0; i < count && i < 10; i++)
            {
                Color c = (sorted[i]->id == my_id) ? GREEN : WHITE;
                DrawText(TextFormat("%d. %s", i + 1, sorted[i]->name), leaderboard_x + 10, 40 + i * 20, 20, c);
                DrawText(TextFormat("%d", sorted[i]->score), leaderboard_x + 160, 40 + i * 20, 20, GRAY);
            }

            /*
            // minimap
            int mm_size = 150;
            int mm_x = GetScreenWidth() - mm_size - 20;
            int mm_y = GetScreenHeight() - mm_size - 20;
            DrawRectangle(mm_x, mm_y, mm_size, mm_size, (Color){0, 0, 0, 100});
            */
        }

        else if (state == STATE_MENU)
        {
            DrawText("slither.c", GetScreenWidth() / 2 - MeasureText("slither.c", 80) / 2, 200, 80, SKYBLUE);

            Rectangle box = {GetScreenWidth() / 2 - 150, GetScreenHeight() / 2, 300, 50};
            DrawRectangleLinesEx(box, 2, WHITE);
            DrawText(name_buffer, box.x + 10, box.y + 10, 30, WHITE);

            // blinking cursor
            if (((int)(GetTime() * 2)) % 2 == 0)
                DrawText("_", box.x + 10 + MeasureText(name_buffer, 30), box.y + 10, 30, WHITE);

            DrawText("Press ENTER to Join", GetScreenWidth() / 2 - 100, box.y + 70, 20, GRAY);

            // DrawText("Use arrow keys to move", GetScreenWidth() / 2 - 100, box.y + 100, 16, GRAY);

            // keyboard input
            int key = GetCharPressed();
            if (key >= 32 && key <= 125 && name_index < 15)
            {
                name_buffer[name_index++] = (char)key;
                name_buffer[name_index] = 0;
            }
            if (IsKeyPressed(KEY_BACKSPACE) && name_index > 0)
            {
                name_buffer[--name_index] = 0;
            }
            if (IsKeyPressed(KEY_ENTER))
            {
                connect_to_server();
                state = STATE_CONNECTING;
            }
        }
        else if (state == STATE_CONNECTING)
        {
            DrawText("Connecting...", GetScreenWidth() / 2 - MeasureText("Connecting...", 40) / 2, GetScreenHeight() / 2, 40, WHITE);
            // TODO: add timeout and error message
        }
        else if (state == STATE_DEAD)
        {
            DrawRectangle(0, 0, GetScreenWidth(), GetScreenHeight(), (Color){0, 0, 0, 200});
            const char *txt = "YOU DIED";
            DrawText(txt, GetScreenWidth() / 2 - MeasureText(txt, 60) / 2, GetScreenHeight() / 2 - 50, 60, RED);
            DrawText(TextFormat("Final Score: %d", player_score), GetScreenWidth() / 2 - 100, GetScreenHeight() / 2 + 20, 30, WHITE);
            // DrawText(TextFormat("High Score: %d", highscore), GetScreenWidth() / 2 - 100, GetScreenHeight() / 2 + 60, 20, GOLD);
            DrawText("Press ENTER to Replay", GetScreenWidth() / 2 - 120, GetScreenHeight() / 2 + 80, 20, GRAY);

            if (IsKeyPressed(KEY_ENTER))
                state = STATE_MENU;
        }

        EndDrawing();
    }

    // cleanup
    UnloadTexture(glow_texture);
    enet_host_destroy(client);
    CloseWindow();
    return 0;
}