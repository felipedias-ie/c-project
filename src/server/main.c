// All doxygen comments were generated by AI, model: gpt-5.

/**
 * @file main.c
 * @brief Authoritative game server - manages physics, collisions, and world state.
 */
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <math.h>
#include <time.h>
#include <enet.h>
#include "../common/shared.h"

// [AI, model: gpt-5] loading config.toml
typedef struct
{
    int tick_rate;
    int port;
    float immunity_seconds;
    int start_score;
    int kill_bonus;
    float base_speed;
    float boost_speed;
    int boost_cost_per_tick;
    int min_score_to_boost;
    float radius_base;
    float radius_growth;
    float radius_max;
    int trail_base;
    int trail_growth_divisor;
    int food_drop_skip;
    int food_drop_value_base;
    int food_drop_value_divisor;
    int food_drop_value_max;
    int food_value_min;
    int food_value_max;
    int bot_count;
    float bot_turn_speed;
    float bot_wiggle;
    int spawn_safe_distance;
    int spawn_max_attempts;
    int collision_body_step;
} Config;

Config cfg = {
    .tick_rate = 60,
    .port = 7777,
    .immunity_seconds = 3.0f,
    .start_score = 10,
    .kill_bonus = 50,
    .base_speed = 3.2f,
    .boost_speed = 5.5f,
    .boost_cost_per_tick = 2,
    .min_score_to_boost = 15,
    .radius_base = 10.0f,
    .radius_growth = 0.015f,
    .radius_max = 80.0f,
    .trail_base = 20,
    .trail_growth_divisor = 3,
    .food_drop_skip = 5,
    .food_drop_value_base = 3,
    .food_drop_value_divisor = 100,
    .food_drop_value_max = 30,
    .food_value_min = 1,
    .food_value_max = 3,
    .bot_count = 20,
    .bot_turn_speed = 0.08f,
    .bot_wiggle = 0.05f,
    .spawn_safe_distance = 500,
    .spawn_max_attempts = 50,
    .collision_body_step = 2
};

/**
 * @brief Load configuration from TOML file.
 * @param path Path to config file
 */
void load_config(const char *path)
{
    FILE *f = fopen(path, "r");
    if (!f)
    {
        printf("Config not found at %s, using defaults\n", path);
        return;
    }

    char line[256];
    while (fgets(line, sizeof(line), f))
    {
        if (line[0] == '#' || line[0] == '[' || line[0] == '\n')
            continue;

        char key[64];
        char value[64];
        if (sscanf(line, "%63[^=]=%63s", key, value) == 2)
        {
            char *k = key;
            while (*k == ' ') k++;
            char *end = k + strlen(k) - 1;
            while (end > k && *end == ' ') *end-- = 0;

            if (strcmp(k, "tick_rate") == 0) cfg.tick_rate = atoi(value);
            else if (strcmp(k, "port") == 0) cfg.port = atoi(value);
            else if (strcmp(k, "immunity_seconds") == 0) cfg.immunity_seconds = atof(value);
            else if (strcmp(k, "start_score") == 0) cfg.start_score = atoi(value);
            else if (strcmp(k, "kill_bonus") == 0) cfg.kill_bonus = atoi(value);
            else if (strcmp(k, "base_speed") == 0) cfg.base_speed = atof(value);
            else if (strcmp(k, "boost_speed") == 0) cfg.boost_speed = atof(value);
            else if (strcmp(k, "boost_cost_per_tick") == 0) cfg.boost_cost_per_tick = atoi(value);
            else if (strcmp(k, "min_score_to_boost") == 0) cfg.min_score_to_boost = atoi(value);
            else if (strcmp(k, "radius_base") == 0) cfg.radius_base = atof(value);
            else if (strcmp(k, "radius_growth") == 0) cfg.radius_growth = atof(value);
            else if (strcmp(k, "radius_max") == 0) cfg.radius_max = atof(value);
            else if (strcmp(k, "trail_base") == 0) cfg.trail_base = atoi(value);
            else if (strcmp(k, "trail_growth_divisor") == 0) cfg.trail_growth_divisor = atoi(value);
            else if (strcmp(k, "skip_segments") == 0) cfg.food_drop_skip = atoi(value);
            else if (strcmp(k, "value_base") == 0) cfg.food_drop_value_base = atoi(value);
            else if (strcmp(k, "value_score_divisor") == 0) cfg.food_drop_value_divisor = atoi(value);
            else if (strcmp(k, "value_max") == 0) cfg.food_drop_value_max = atoi(value);
            else if (strcmp(k, "value_min") == 0) cfg.food_value_min = atoi(value);
            else if (strcmp(k, "count") == 0) cfg.bot_count = atoi(value);
            else if (strcmp(k, "turn_speed") == 0) cfg.bot_turn_speed = atof(value);
            else if (strcmp(k, "wiggle_amount") == 0) cfg.bot_wiggle = atof(value);
            else if (strcmp(k, "safe_distance") == 0) cfg.spawn_safe_distance = atoi(value);
            else if (strcmp(k, "max_attempts") == 0) cfg.spawn_max_attempts = atoi(value);
            else if (strcmp(k, "body_check_step") == 0) cfg.collision_body_step = atoi(value);
        }
    }
    fclose(f);
    printf("Config loaded from %s\n", path);
}

typedef struct
{
    ENetPeer *peer;
    int active;
    int id;
} Client;

typedef struct
{
    float x, y, angle;
    int score;
    int dead;
    int is_bot;
    int immunity;
    int boosting;
    ColorRGB color;
    char name[32];

    struct
    {
        float x, y;
    } path[MAX_TRAIL];
    int path_length;
} ServerSnake;

Client clients[MAX_CLIENTS];
ServerSnake snakes[MAX_CLIENTS];
NetFood foods[MAX_FOOD];
uint32_t world_seq = 0;

/**
 * @brief Generate a random float in range [min, max].
 * @param min Minimum value
 * @param max Maximum value
 * @return Random float
 */
float random_float(float min, float max) { 
    return min + (float)rand() / (float)(RAND_MAX / (max - min)); 
}

/**
 * @brief Calculate squared distance between two points.
 * @param x1 First point X
 * @param y1 First point Y
 * @param x2 Second point X
 * @param y2 Second point Y
 * @return Squared distance (avoids sqrt for performance)
 */
float distance_squared(float x1, float y1, float x2, float y2) { 
    return (x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1); 
}

/**
 * @brief Get snake radius based on score.
 * @param score Snake's current score
 * @return Radius capped at config max
 */
float get_snake_radius(int score)
{
    float sz = cfg.radius_base + score * cfg.radius_growth;
    if (sz > cfg.radius_max)
        sz = cfg.radius_max;
    return sz;
}

// [AI, model: gpt-5] was used to design this function.
/**
 * @brief Find a spawn point away from other snakes.

   why ? because while designing the game we noticed that snakes would constantly spawn in front of the player,
   resulting in instant death. - annoying.
 
 * @param my_idx Index of the snake being spawned+
 * @param x Output X coordinate
 * @param y Output Y coordinate
 */
void find_safe_spawn(int my_idx, float *x, float *y)
{
    float safe_dist_sq = cfg.spawn_safe_distance * cfg.spawn_safe_distance;

    for (int try = 0; try < cfg.spawn_max_attempts; try++)
    {
        float a = random_float(0, 6.28f);
        float d = random_float(0, WORLD_SIZE / 2 - 500);
        *x = cosf(a) * d;
        *y = sinf(a) * d;

        int safe = 1;
        for (int i = 0; i < MAX_CLIENTS; i++)
        {
            if (i == my_idx || snakes[i].dead)
                continue;
            if (distance_squared(*x, *y, snakes[i].x, snakes[i].y) < safe_dist_sq)
            {
                safe = 0;
                break;
            }
        }
        if (safe)
            return;
    }
    *x = 0;
    *y = 0;
}

/**
 * @brief Spawn food at random position within world bounds.
 * @param i Food slot index to populate
 */
void spawn_food(int i)
{
    float a = random_float(0, 6.28f);
    float d = random_float(0, WORLD_SIZE / 2 - 50);

    // random food position and value
    foods[i].id = i;
    foods[i].x = (int16_t)(cosf(a) * d);
    foods[i].y = (int16_t)(sinf(a) * d);
    foods[i].val = cfg.food_value_min + (rand() % (cfg.food_value_max - cfg.food_value_min + 1));

    // random food color
    foods[i].r = rand() % 200 + 55;
    foods[i].g = rand() % 200 + 55;
    foods[i].b = rand() % 200 + 55;
}

/**
 * @brief Drop food along dead snake's trail.
 *
 * Drops food at trail nodes, skipping segments to avoid clusters.
 *
 * @param snake_idx Index of the dead snake
 */
void drop_food(int snake_idx)
{
    int count = snakes[snake_idx].path_length;
    for (int k = 0; k < count; k += cfg.food_drop_skip)
    {
        int f = rand() % MAX_FOOD;
        foods[f].x = (int16_t)snakes[snake_idx].path[k].x;
        foods[f].y = (int16_t)snakes[snake_idx].path[k].y;
        foods[f].val = cfg.food_drop_value_base + (snakes[snake_idx].score / cfg.food_drop_value_divisor);

        if (foods[f].val > cfg.food_drop_value_max)
            foods[f].val = cfg.food_drop_value_max;

        foods[f].r = snakes[snake_idx].color.r;
        foods[f].g = snakes[snake_idx].color.g;
        foods[f].b = snakes[snake_idx].color.b;
    }
}

/**
 * @brief Initialize or respawn a snake.
 * @param i Snake slot index
 * @param is_bot 1 if bot, 0 if player
 * @param name Display name
 */
void init_snake(int i, int is_bot, const char *name)
{
    snakes[i].is_bot = is_bot;
    snakes[i].dead = 0;
    snakes[i].score = cfg.start_score;
    snakes[i].immunity = (int)(cfg.immunity_seconds * cfg.tick_rate);
    snakes[i].boosting = 0;

    find_safe_spawn(i, &snakes[i].x, &snakes[i].y);
    snakes[i].angle = atan2f(-snakes[i].y, -snakes[i].x);

    if (snakes[i].name != name)
    {
        strncpy(snakes[i].name, name, 15);
        snakes[i].name[15] = 0;
    }

    snakes[i].color.r = is_bot ? 255 : 0;
    snakes[i].color.g = is_bot ? 50 : 255;
    snakes[i].color.b = is_bot ? 0 : 255;
    if (is_bot)
    {
        snakes[i].color.g = rand() % 255;
        snakes[i].color.b = rand() % 100;
    }

    snakes[i].path_length = cfg.trail_base;
    for (int k = 0; k < MAX_TRAIL; k++)
    {
        snakes[i].path[k].x = snakes[i].x;
        snakes[i].path[k].y = snakes[i].y;
    }
}

// [AI, model: gpt-5] was used to design this function.
/**
 * @brief Basic AI for bot snakes.
 * @param i Bot snake index
 */
void update_bot(int i)
{
    if (distance_squared(0, 0, snakes[i].x, snakes[i].y) > (WORLD_SIZE / 2 - 200) * (WORLD_SIZE / 2 - 200))
    {
        float target = atan2f(-snakes[i].y, -snakes[i].x);
        float diff = target - snakes[i].angle;

        while (diff <= -M_PI)
            diff += 2 * M_PI;

        while (diff > M_PI)
            diff -= 2 * M_PI;

        snakes[i].angle += diff * cfg.bot_turn_speed;
        return;
    }

    snakes[i].angle += random_float(-cfg.bot_wiggle, cfg.bot_wiggle);
}

// [AI, model: gpt-5] was used to design config loading & boost logic.
/**
 * @brief Server main loop.
 * @param argc Argument count
 * @param argv Arguments: [1] = port
 * @return 0 on success, 1 on failure
 */
int main(int argc, char **argv)
{
    setbuf(stdout, NULL);
    srand(time(0));

    load_config("config.toml");

    if (enet_initialize() != 0)
        return 1;

    ENetAddress address     = {0};
    address.host           = ENET_HOST_ANY;
    address.port           = cfg.port;

    if (argc > 1)
        address.port        = atoi(argv[1]);

    ENetHost *server       = enet_host_create(&address, MAX_CLIENTS, 2, 0, 0);
    if (server == NULL)
    {
        printf("Failed to create server on port %d\n", address.port);
        return 1;
    }

    for (int i = 0; i < MAX_CLIENTS; i++)
        clients[i].active   = 0;
    for (int i = 0; i < MAX_FOOD; i++)
        spawn_food(i);

    int bot_start          = 10;
    int bot_end            = bot_start + cfg.bot_count;
    for (int i = bot_start; i < bot_end && i < MAX_CLIENTS; i++)
    {
        char b[16];
        sprintf(b, "Bot %d", i);
        init_snake(i, 1, b);
    }

    printf("Server ready on port %d\n", address.port);

    while (1)
    {
        ENetEvent event;
        while (enet_host_service(server, &event, 0) > 0)
        {
            if (event.type == ENET_EVENT_TYPE_CONNECT)
            {
                printf("Connection from %x\n", event.peer->address.host);
            }
            else if (event.type == ENET_EVENT_TYPE_RECEIVE)
            {
                uint8_t type = event.packet->data[0];
                int      id  = -1;
                for (int i = 0; i < MAX_CLIENTS; i++)
                    if (clients[i].active && clients[i].peer == event.peer)
                        id = i;

                if (type == JOIN_PACKET)
                {
                    if (event.packet->dataLength < sizeof(JoinPacket))
                    {
                        enet_packet_destroy(event.packet);
                        continue;
                    }
                    JoinPacket *p = (JoinPacket *)event.packet->data;
                    p->name[15]    = 0;

                    int existing_id = -1;
                    for (int i = 0; i < MAX_CLIENTS; i++)
                    {
                        if (clients[i].active && clients[i].peer == event.peer)
                        {
                            existing_id = i;
                            break;
                        }
                    }

                    if (existing_id != -1)
                    {
                        init_snake(existing_id, 0, p->name);
                        InitPacket  init = {INIT_PACKET, (uint16_t)existing_id, WORLD_SIZE};
                        ENetPacket *resp = enet_packet_create(&init, sizeof(init), ENET_PACKET_FLAG_RELIABLE);
                        enet_peer_send(event.peer, 0, resp);
                        printf("Player %s respawned as ID %d\n", p->name, existing_id);
                    }

                    else
                    {
                        int assigned = -1;
                        for (int i = 0; i < MAX_CLIENTS; i++)
                        {
                            if (!clients[i].active)
                            {
                                clients[i].active = 1;
                                clients[i].peer   = event.peer;
                                clients[i].id     = i;
                                init_snake(i, 0, p->name);

                                InitPacket  init = {INIT_PACKET, (uint16_t)i, WORLD_SIZE};
                                ENetPacket *resp = enet_packet_create(&init, sizeof(init), ENET_PACKET_FLAG_RELIABLE);
                                enet_peer_send(event.peer, 0, resp);
                                printf("Player %s joined as ID %d\n", p->name, i);
                                assigned = i;
                                break;
                            }
                        }
                        if (assigned == -1)
                            printf("Server full!\n");
                    }
                }

                else if (type == INPUT_PACKET && id != -1)
                {
                    if (event.packet->dataLength < sizeof(InputPacket))
                    {
                        enet_packet_destroy(event.packet);
                        continue;
                    }
                    InputPacket *p = (InputPacket *)event.packet->data;
                    if (!snakes[id].dead)
                    {
                        snakes[id].angle    = p->angle;
                        snakes[id].boosting = p->boost;
                    }
                }
                enet_packet_destroy(event.packet);
            }

            else if (event.type == ENET_EVENT_TYPE_DISCONNECT)
            {
                for (int i = 0; i < MAX_CLIENTS; i++)
                {
                    if (clients[i].active && clients[i].peer == event.peer)
                    {
                        clients[i].active = 0;
                        snakes[i].dead    = 1;
                        drop_food(i);
                        printf("Client %d disconnected\n", i);
                    }
                }
            }
        }

        for (int i = 0; i < MAX_CLIENTS; i++)
        {
            if (snakes[i].dead)
            {
                if (snakes[i].is_bot && rand() % 100 == 0)
                {
                    char temp_name[32];
                    strncpy(temp_name, snakes[i].name, 31);
                    temp_name[31] = 0;
                    init_snake(i, 1, temp_name);
                }
                continue;
            }

            if (snakes[i].immunity > 0)
                snakes[i].immunity--;

            if (snakes[i].is_bot)
                update_bot(i);

            float speed = cfg.base_speed;

            if (snakes[i].boosting && snakes[i].score > cfg.min_score_to_boost)
            {
                speed             = cfg.boost_speed;
                snakes[i].score  -= cfg.boost_cost_per_tick;
                if (snakes[i].score < cfg.min_score_to_boost)
                    snakes[i].boosting = 0;
            }

            snakes[i].x += cosf(snakes[i].angle) * speed;
            snakes[i].y += sinf(snakes[i].angle) * speed;

            if (distance_squared(snakes[i].x, snakes[i].y, snakes[i].path[0].x, snakes[i].path[0].y) > speed * speed)
            {
                memmove(&snakes[i].path[1], &snakes[i].path[0], sizeof(snakes[i].path) - sizeof(snakes[i].path[0]));
                snakes[i].path[0].x = snakes[i].x;
                snakes[i].path[0].y = snakes[i].y;

                int target_length = cfg.trail_base + snakes[i].score / cfg.trail_growth_divisor;
                if (target_length > MAX_TRAIL)
                    target_length = MAX_TRAIL;
                snakes[i].path_length = target_length;
            }

            if (distance_squared(0, 0, snakes[i].x, snakes[i].y) > (WORLD_SIZE / 2) * (WORLD_SIZE / 2))
            {
                snakes[i].dead = 1;
                drop_food(i);
                if (clients[i].active)
                {
                    DiePacket  die = {DIE_PACKET, snakes[i].score};
                    ENetPacket *p  = enet_packet_create(&die, sizeof(die), ENET_PACKET_FLAG_RELIABLE);
                    enet_peer_send(clients[i].peer, 0, p);
                }
            }

            float player_radius = get_snake_radius(snakes[i].score);

            for (int j = 0; j < MAX_CLIENTS; j++)
            {
                if (i == j || snakes[j].dead)
                    continue;
                if (snakes[i].immunity > 0)
                    continue;

                float enemy_radius           = get_snake_radius(snakes[j].score);
                float collision_distance_sq  = (player_radius + enemy_radius) * (player_radius + enemy_radius);

                for (int k = 0; k < snakes[j].path_length; k += cfg.collision_body_step)
                {
                    if (distance_squared(snakes[i].x, snakes[i].y, snakes[j].path[k].x, snakes[j].path[k].y) < collision_distance_sq)
                    {
                        snakes[i].dead    = 1;
                        drop_food(i);
                        snakes[j].score  += cfg.kill_bonus;

                        if (clients[i].active)
                        {
                            DiePacket  die = {DIE_PACKET, snakes[i].score};
                            ENetPacket *p  = enet_packet_create(&die, sizeof(die), ENET_PACKET_FLAG_RELIABLE);
                            enet_peer_send(clients[i].peer, 0, p);
                        }
                        break;
                    }
                }
                if (snakes[i].dead)
                    break;
            }

            if (!snakes[i].dead)
            {
                for (int f = 0; f < MAX_FOOD; f++)
                {
                    float food_radius = 15.0f + foods[f].val * 2.0f;
                    float eat_distance = (player_radius + food_radius);

                    if (distance_squared(snakes[i].x, snakes[i].y, foods[f].x, foods[f].y) < eat_distance * eat_distance)
                    {
                        snakes[i].score += foods[f].val;
                        spawn_food(f);
                    }
                }
            }
        }

        world_seq++;
        uint16_t snake_count = 0, food_count = 0;
        for (int i = 0; i < MAX_CLIENTS; i++)
            if (!snakes[i].dead)
                snake_count++;
        for (int i = 0; i < MAX_FOOD; i++)
            food_count++;

        size_t buffer_size   = sizeof(WorldPacket) + snake_count * sizeof(NetSnake) + food_count * sizeof(NetFood);
        uint8_t *buf        = malloc(buffer_size);
        WorldPacket *h      = (WorldPacket *)buf;
        h->type             = WORLD_PACKET;
        h->sequence         = world_seq;
        h->snake_count      = snake_count;
        h->food_count       = food_count;

        uint8_t *ptr        = buf + sizeof(WorldPacket);
        for (int i = 0; i < MAX_CLIENTS; i++)
        {
            if (!snakes[i].dead)
            {
                NetSnake ns;
                ns.id       = i;
                ns.x        = (int16_t)snakes[i].x;
                ns.y        = (int16_t)snakes[i].y;
                ns.angle    = (int16_t)(snakes[i].angle * 57.29f);
                ns.score    = snakes[i].score;
                ns.dead     = 0;
                ns.immunity = snakes[i].immunity;
                ns.r        = snakes[i].color.r;
                ns.g        = snakes[i].color.g;
                ns.b        = snakes[i].color.b;
                strncpy(ns.name, snakes[i].name, 15);
                ns.trail_len = snakes[i].path_length;
                for (int k = 0; k < ns.trail_len; k++)
                {
                    ns.trail_x[k] = (int16_t)snakes[i].path[k].x;
                    ns.trail_y[k] = (int16_t)snakes[i].path[k].y;
                }
                memcpy(ptr, &ns, sizeof(NetSnake));
                ptr += sizeof(NetSnake);
            }
        }
        for (int i = 0; i < MAX_FOOD; i++)
        {
            memcpy(ptr, &foods[i], sizeof(NetFood));
            ptr += sizeof(NetFood);
        }

        for (int i = 0; i < MAX_CLIENTS; i++)
        {
            if (clients[i].active)
            {
                ENetPacket *p = enet_packet_create(buf, buffer_size, ENET_PACKET_FLAG_UNSEQUENCED);
                enet_peer_send(clients[i].peer, 1, p);
            }
        }
        free(buf);

        enet_host_flush(server);
        usleep(1000000 / cfg.tick_rate);
    }
    enet_host_destroy(server);
    return 0;
}